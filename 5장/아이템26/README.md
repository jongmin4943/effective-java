## 4장 클래스와 인터페이스

------------------

#### 아이템 26 . Raw 타입은 사용하지 말리

클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 혹은 제네릭 인터페이스라 한다. List<br/>
인터페이스는 원소 타입을 나타내는 타입 매개변수 E 를 받는다. 그래서 인터페이스의 완전한 이름은 List<E> 지만,<br/>
짧게 그냥 List 라고도 자주 쓴다. 제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입이라 한다.

각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다. 먼저 클래스 혹은 인터페이스 이름이 나오고, 이어서<br/>
꺽쇠괄호 안에 실제 타입 매개변수들을 나열한다. 예컨대 List<String> 은 원소의 타입이 String 인 리스트<br/>
를 뜻하는 매개변수화 타입이다. 여기서 String 이 정규타입 매개변수 E 에 해당하는 실제 타입 매개변수다.

마지막으로, 제네릭 타입을 하나 정의하면 그에 딸린 raw 타입 도 함께 정의된다. raw 타입이란 제네릭 타입에서<br/>
타입 매개변수를 전혀 사용하지 않을 때를 말한다. 예컨대 List<E> 의 raw 타입은 List 다. raw 타입은<br/>
타입선언에서 제네릭 타입 정보가 전부 지워진것처럼 동작하는다, 제네릭이 도래하기 전 코드와 호환되도록<br/>
하기위한 궁여지책이라 할 수 있다.

제네릭을 지원하기 전에는 컬렉션을 다음과 같이 선언했다. 자바 9에서도 여전히 동작하지만 좋은 예는 아니다.
```java
private final Collection stamps = ...;
```
이 코드를 사용하면 실수로 Stamp 대신 Coin 을 넣어도 아무 오류없이 컴파일 되고 실행된다. 컬렉션에서<br/>
Coin 을 다시 꺼내기전에는 오류를 알아채지 못한다.

이 책 전반에서 줄기차게 이야기하듯, 오류는 가능한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다.<br/>
이 예에서는 오류가 발생하고 한참 뒤인 런타임에야 알아챌 수 있는데, 이렇게 되면 런타임에 문제를 겪는 코드와<br/>
원인을 제공한 코드가 물리적으로 상당히 떨어져 있을 가능성이 커진다. <br/>
제네릭을 활용하면 정보가 주석이 아닌 타입 선언자체에 녹아든다.
```java
private final Collection<Stamp> stamps = ...;
```
이렇게 선언하면 컴파일러는 stamps 에는 Stamp 의 인스턴스만 넣어야 함을 컴파일러가 인지하게 된다.<br/>
따라서 아무런 경고 없이 컴파일 된다면 의도대로 동작할 것임을 보장한다. 물론 컴파일러 경고를 숨기지 <br/>
않았어야 한다. 이제 stamps 에 엉뚱한 타입의 인스턴스를 넣으려하면 컴파일 오류가 발생하며<br/>
무엇이 잘못됐는지를 정확히 알려준다. 컴파일러는 컬렉션에서 원소를 꺼내는 모든 곳에 보이지 않는<br/>
형변환을 추가하여 절대 실패하지 않음을 보장한다. Stamp 용 컬렉션에 Coin 을 넣는다는 예가 억지스러워<br/>
보이겠지만, 현업에서도 종종 일어나는 일이다. 예컨대 BigDecimal 용 컬렉션에 BigInteger 를 넣는<br/>
실수는 그리 억지 같지 않을 것이다.