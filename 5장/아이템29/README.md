## 4장 클래스와 인터페이스

------------------

#### 아이템 29 . 이왕이면 제네릭 타입으로 만들라

JDK 가 제공하는 제네릭 타입과 메서드를 사용하는 일은 일반적으로 쉬운편이지만, 제네릭 타입을 새로 만드는<br/>
일은 조금 더 어렵다. E 와 같은 실체화 불가 타입으로는 배열을 만들 수 없다. 배열을 사용하는 코드를 제네릭<br/>
으로 만들려 할 때는 이 문제가 항상 발목을 잡을 것이다. 적절한 해결책은 두가지다. 첫번째는 제네릭 배열<br/>
생성을 금지하는 제약을 대놓고 우회하는 방법이다. Object 배열을 생성한 다음 제네릭 배열로 형변환해보자.<br/>
이제 컴파일러는 오류 대신 경고를 내보낼 것이다. 하지만 일반적으로 타입 안전하지 않다.
```java
elements = new E[DEFAULT_INITAL_CAPACITY];
// ->
elements = (E()) new Object[DEFAULT_INITIAL_CAPACITY];
```
컴파일러는 이 프로그램이 타입 안전한지 증명할 방법이 없지만 우리는 할 수 있다. 따라서 이 비검사 형변환이<br/>
프로그램의 타입 안정성을 해치지 않음을 우리 스스로 확인해야 한다. 문제의 배열 elements 는 private<br/>
필드에 저장되고, 클라이언트로 반환되거나 다른 메서드에 전달되는 일이 전혀 없다. push 메서드를 통해 배열에<br/>
저장되는 원소의 타입은 항상 E 이다. 따라서 이 비검사 형변환은 확실히 안전하다.

비검사 형변환이 안전함을 직접 증명했다면 범위를 최소로 좁혀 @SuppressWarnings 애너테이션으로 해당 경고를<br/>
숨긴다. 이 예에서는 생성자가 비검사 배열 생성 말고는 하는 일이 없으니 생성자 전체에서 경고를 숨겨도 좋다.<br/>
애너테이션을 달면 깔끔히 컴파일되고, 명시적으로 형변환 하지 않아도 ClassCastException 걱정 없이 사용가능하다.<br/>

제네릭 배열 생성 오류를 해결하는 두번째 방법은 elements 필드의 타입을 E[] 에서 Object[] 로 바꾸는 것이다.<br/>
이렇게 하면 첫번째와는 다른 오류가 발생한다. E 는 실체화 불가 타입이므로 컴파이러라는 런타임에 이뤄지는<br/>
형변환이 안전한지 증명할 방법이 없다. 이번에도 마찬가지로 우리가 직접 증명하고 경고를 숨길 수 있다.<br/>

제네릭 배열 생성을 제거하는 두 방법 모두 나름의 지지를 얻고 있다. 첫번째 방법은 가독성이 더 좋다.<br/>
배열의 타입을 E[] 로 선언하여 오직 E 타입 인스턴스만 받음을 확실히 어필한다. 코드도 더 짧다.<br/>
보통의 제네릭 클래스라면 코드 이곳저곳에서 이 배열을 자주 사용할 것이다. 첫번째 방식에서는 형변환을<br/>
배열 생성시 단 한번만 해주면 되지만, 두번째 방식에서는 배열에서 원소를 읽을때마다 해줘야한다. 따라서<br/>
현업에서는 첫번째 방식을 더 선호하며 자주 사용한다. 하지만 배열의 런타임 타입이 컴파일타임 타입과 달라<br/>
힘 오염(?)을 일으킨다. 힙 오염이 맘에 걸리는 프로그래머는 두번째 방식을 고수하기도 한다.

다음은 명령줄 인수들을 역순으로 바꿔 대문자로 출력하는 프로그램으로, 방금 만든 제네릭 Stack 클래스를<br/>
사용하는 모습을 보여준다. Stack 에서 꺼낸 원소에서 String 의 toUpperCase 메서드를 호출할 때 명시적<br/>
형변환을 수행하지 않으며, 이 형변환이 항상 성공함을 보장한다.
```java
public static void main(String[] args) {
    Stack<String> stack = new Stack();
    for (String arg: args)
        stack.push(arg);
    while (!stack.isEmpty())
        System.out.println(stack.pop().toUpperCase());
} 
```
지금까지 설명한 Stack 예는 "배열보다는 리스트를 우선하라" 는 아이템 28과 모순되어 보인다. 사실 제네릭<br/>
타입 안에서 리스트를 사용하는 게 항상 가능하지도, 꼭 더 좋은것도 아니다. 자바가 리스트를 기본타입으로<br/>
제공하지 않으므로, ArrayList 같은 제네릭 타입도 결국은 기본 타입인 배열을 사용해 구현해야 한다. 또한,
HashMap 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 한다.

Stack 예처럼 대다수의 제네릭 타입은 타입 매개변수에 아무런 제약을 두지 않는다. Stack<Object>,<br/>
Stack<int[]>, Stack<List<String>>, Stack 등 어떤 참조타입으로도 Stack 을 만들 수 있다.<br/>
단, 기본 타입은 사용할 수 없다. 이는 자바 제네릭 타입 시스템의 근본적인 문제이나, 박싱된 기본타입을 사용해<br/>
우회할 수 있다.

타입 매개변수에 제약을 두는 제네릭 타입도 있다.
```java
class DelayQueue<E extends Delayed> implements BlockingQueue<E>
```
타입 매개변수 목록인 <E extends Delayed> 는 Delayed 의 하위 타입만 받는다는 뜻이다. 이렇게 하여<br/>
DelayQueue 자신과 DelayQueue 를 사용하는 클라이언트는 DelayQueue 의 원소에서 형변환 없이 곧바로<br/>
Delayed 클래스의 메서드를 호출할 수 있다. ClassCastException 걱정은 할 필요가 없다. 이러한 타입<br/>
매개변수 E 를 한정적 타입 매개변수라 한다. 그리고 모든 타입은 자기 자신의 하위타입이므로 DelayQueue<Delayed><br/>
로도 사용할 수 있음을 기억해두자.

> 핵심정리<br/>
> 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다. 그러니 새로운 타입을
> 설계할 때는 형변환 없이도 사용할 수 있도록 하라. 그렇게 하려면 제네릭 타입으로 만들어야 할 경우가 많다.
> 기존 타입 중 제네릭이었어야 하는게 있다면 제네릭 타입으로 변경하자. 기존 클라이언트에는 아무 영향을
> 주지 않으면서, 새로운 사용자를 훨씬 편하게 해주는 길이다.