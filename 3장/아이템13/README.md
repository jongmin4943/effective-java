## 3장 모든객체의 공통 메서드

------------------

#### 아이템 13 . clone 재정의는 주의해서 진행하라

Cloneable 은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스(mixin interface)지만, <br/>
아쉽게도 의도한 목적을 제대로 이루지 못했다. 가장 큰 문제는 clone 메서드가 선언된곳이 Cloneable이 <br/>
아닌 Object 이고, 그마저도 protected 라는데 있다. 그래서 Cloneable 을 구현하는것만으로는 외부 객체에서<br/>
clone 메서드를 호출할 수 없다. 리플렉션을 사용하면 가능하지만, 100% 성공하는 것도 아니다. 해당 객체가 접근이<br/>
허용된 clone 메서드를 제공한다는 보장이 없기 때문이다. 하지만 이를 포함한 여러 문제점에도 불구하고 <br/>
Cloneable 방식은 널리 쓰이고 있어서 잘 알아두는 것이 좋다. 이번 아이템에서는 clone 메서드를 잘 동작하게끔<br/>
해주는 구현 방법과 언제 그렇게 해야하는지를 알려주고, 가능한 다른 선택지에 관해 논의한다.<br/>

메서드 하나 없는 Cloneable 인터페이스는 놀랍게도 Object 의 protected 메서드인 clone 의</br>
동작 방식을 결정한다. Cloneable 을 구현한 클래스의 인스턴스에서 clone 을 호출하면 그 객체의 </br>
필드들을 하나하나 복사한 객체를 반환하며, 그렇지 않은 클래스의 인스턴스에서 호출하면 CloneNotSupportException</br>
을 던진다. 이는 인터페이스를 상당히 이례적으로 사용한 예이니 따라하지는 말자. 인터페이스를 구현한다는</br>
것은 일반적으로 해당 클래스가 그 인터페이스에서 정의한 기능을 제공한다고 선언하는 행위다. </br>
그런데 Cloneable 의 경우에는 상위 클래스에 정의된 protected 메서드의 동작 방식을 변경한 것이다.