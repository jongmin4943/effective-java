## 2장 객체 생성과 파괴


------------------

#### 아이템 8 . finalizer 와 cleaner 사용을 피하라

자바의 두가지 소멸자 중 하나인 finalizer 는 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.<br/>
오동작, 낮은 성능, 이식성 문제의 원인이 되기도 한다. 그래서 기본적으로 쓰지 말아야 한다. <br/>
자바 9 부터는 deprecated API 로 지정하고 cleaner 를 대안으로 소개했다. cleaner 는 finalize 보다는<br/> 
덜 위엄하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요 하다.<br/>
finalizer 와 cleaner 는 즉시 수행된다는 보장이 없다. 즉, <strong>finalizer 와 cleaner 로는 제때 실행되어야 하는 <br/>
작업은 절대 할 수 없다.</strong> 예컨대, 파일 닫기를 finalizer 와 cleaner 에 맡기면 중대한 오류가 날 수 있다.<br/>
시스템이 동시에 열 수 있는 파일 개수에 한계가 있기 때문이다. 즉 새로운 파일을 열지 못해 프로그램이 실패할 수 있다.<br/>
finalizer 와 cleaner 는 전적으로 가비지 컬렉터 알고리즘에 의해 결정되며 이는 가바지 컬렉터 구현마다 천차만별이다.<br/>
이 둘의 수행 시점에 의존하는 프로그램의 동작 또한 마찬가지다. <br/>

클래스에 finalizer 를 달아두면 그 인스턴스의 자원 회수가 제멋대로 지연될 수 있다. finalizer 스레드는 다른 <br/>
어플리케이션 스레드보다 우선순위가 낮아서 실행될 기회를 제대로 얻지 못한 것이다. 어떤 스레드가 finalizer 를 수행할지<br/>
명시하지 않으니 이 문제를 예방할 보편적인 해법은 없다. 딱 하나 사용하지 않는 방법뿐이다. 한편 cleaner 는 스레드를 제어<br/>
할수 있다는 면에서 조금 낫다. 하지만 여전히 백그라운드에서 수행되며 가비지 컬렉터의 통제하에 즉각 수행되리라는 보장이 없다.<br/>

접근할 수 없는 일부 객체에 딸린 종료 작업을 전혀 수행하지 못한 채 프로그램이 중단될 수도 있다. 따라서 <br/>
프로그램 생애주기와 상관없는, <strong>상태를 영구적으로 수정하는 작업에서는 절대 finalizer 나 cleaner 에 의존해서는 안된다.</strong><br/>
데이터베이스 같은 공유 자원의 영구 lock 해제를 finalizer 나 cleaner 에 맡겨 놓으면 분산 시스템 전체가 서서히 멈출것이다.<br/>

System.gc 나 System.runFinalization 메서드는 실행될 가능성을 높여줄뿐, 보장해주진 않는다. 사실 이를 보장해주겠다는 <br/>
메서드가 2개 있다. System.runFinalizersOnExit 와 Runtime.runFinalizerOnExit 이다. 하지만 이 두개의 메서드는 <br/>
심각한 결함 때문에 수십년간 지탄받아왔다. (ThreadStop)

finalizer 의 부작용은 여기서 끝이 아니다. finalizer 동작 중 발생한 예외는 무시되며, 처리할 작업이 남았더라도 그 순간 종료된다.<br/>
잡지 못한 예외 때문에 해당 객체는 자칫 마무리가 덜 된 상태로 남을 수 있다. 거기에 다른 스레드가 이처럼 훼손된 객체를 사용하려 한다면 <br/>
어떻게 동작할지 예측할 수 없다. 보통의 경우엔 잡지 못한 예외가 스레드를 중단시키고 Stack trace 를 출력하지만, 같은 일이 finalizer <br/>
에서 일어난다면 경고조차 출력하지 않는다. 그나마 cleaner 는 자신의 스레드를 통제하기 때문에 이러한 문제가 발생하지 않는다.