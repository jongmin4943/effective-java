## 2장 객체 생성과 파괴


------------------
### 아이템 1 . 생성자 대신 정적 팩터리 메서드를 고려하라

####정적 팩터리 메서드의 장점
1. 이름을 가질 수 있다. <br/>
 -- 생성자에 넘기는 매개변수와 생성자 자체만으로는 반환 될 객체의 특성을 제대로 설명하지 못한다.<br/>
 -- 정적 팩터리 매서드는 이름만 잘 지으면 특성을 쉽게 묘사할 수 있다. <br/>
 -- 생성자 같은 경우 하나의 시그니처 로는 생성자를 하나만 만들 수 있다.
2. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다. <br/>
 -- 불변 클래스(immutable class)는 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용 하는식으로 불필요한 객체 생성을 피할 수 있다.<br/>
 -- 대표적인 예인 Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않는다. 따라서 같은 객체가 자주 요청되는 상황이라면 성능이 항샹 된다. (플라이웨트 패턴) <br/>
 -- 정적 팩터리 방식은 언제 어느 인스턴스를 살아 있게 할지를 철저히 통제할 수 있다. (인스턴스 통제 instance-controlled)<br/>
 -- 통제를 통해 싱글톤 패턴이나 인스턴스화 불가(noninstantiable) 로 만들수 있다. 또한 불변 값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다.
 -- 인스턴스 통제는 플라이웨트 패턴의 근간이 되며, 열거타입은 인스턴스가 하나만 만들어짐을 보장한다.
3. 반환 타입의 하위 타입 객체를 반활할 수 있는 능력이 있다.<br/>
 -- API 를 만들때 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있다.<br/>
 -- 자바 8 전에는 정적 메서드가 필요하면 인스턴스화 불가인 동반 클래스(companion class)를 만들어 정의했다. <br/>
 -- 예를 들면 컬렉션(Collection) 프레임워크는 45개의 유틸리티 구현체를 제공하는데 대부분 Collections 정적 팩터리 메서드를 통해 얻도록 했다. <br/>
 -- 컬렉션 프레임워크는 이 45개 클래스를 공개하지 않기때문에 API 외견을 훨씬 작게 만들어 개념적인 무게, 즉 프래고르매는 명시한 인터페이스대로 동작하는 객체를 얻을 것임을 알기에 <br/>
 -- 굳이 별도 문서를 찾아가며 알아보지 않아도 된다. 나아가 사용하는 클라이언트는 객체의 인스터페이스만 다루게되는 좋은 습관을 가지게 된다.<br/>
 -- 자바 8 부터는 인터페이스가 정적 메서드를 가질수 있고 자바 9에서는 private 정적 메서드까지 허락하지만 정적 필드와 정적 멤버 클래스는 여전히 public 이어야 한다.
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반활할 수 있다.<br/>
 -- 반환 타입의 하위 탕비이기만 하면 어떤 클래스의 객체를 반환해도 된다.<br/>
 -- 예를들면 EnumSet 클래스는 public 생성자 없이 오직 정적 팩터리만 제공하는데, OpenJDK 에서는 원소의 수에 따라 두가지 하위 클래스중 하나의 인스턴스를 반환한다. <br/>
 -- 원소가 64개 이하면 원소들을 long 변수 하나로 관리하는 RegularEnumSet, 65개 이상이면 long 배열로 관리하는 JumboEnumSet 인스턴스를 반환한다. <br/>
 -- 클라이언트는 이 존재를 모른다. 만약 둘중에 하나를 삭제해도 아무 문제가 없다. 성능을 더 개선한 세번째, 네번째 클래스를 추가해도 문제가 없다.
 -- 클라이언트는 객체가 어느 클래스의 인스턴스인지 알 수도, 필요도 없다.
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.<br/>
 -- 이러한 유연함은 서비스 제공자 프레임워크를 만드는 근간이 된다. (예 : JDBC)<br/>
 -- 서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이뤄진다.<br/> 
   1. 구현체의 동작을 정의하는 서비스 인터페이스(service interface).<br/>
   2. 제공자가 구현체를 등록할 때 사용하는 제공자 등록 API(provider registration API)<br/>
   3. 클라이언트가 서비스의 인스턴스를 얻을 때 사용하는 서비스 접근 API(service access API)<br/>

　　-- 클라이언트는 서비스 접근 API 를 사용할 때 원하는 구현체의 조건을 명시할 수 있다. 조건을 명시하지 않으면 기본 구현체를 반환하거나 지원하는 구현체를 하나씩 돌아가며 반환한다. <br/>
　　-- 3개의 핵심 컴포넌트와 더불어 종종 서비스 제공자 인터페이스(service provider interface)라는 네번째 컴포넌트가 쓰이기도 한다. <br/>
　　-- 서비스 제공자 인터페이스가 없다면 각 구현체를 인스턴스로 만들때 리플렉션을 사용해야한다. <br/>
　　JDBC 에서는 Connection 이 서비스 인터페이스 역할을,<br/>
  　　DriverManager.registerDriver 가 제공자 등록 API 역할을,<br/>
  　　DriverManager.getConnection 이 서비스 접근 API 역할을,<br/>
  　　Driver가 서비스 제공자 인터페이스 역할을 수행한다.<br/>

　　-- 서비스 제공자 프레임워크 패턴에는 여러 변형이 있다. 서비스 접근 API 는 공급자가 제공하는 것보다 더 풍부한 서비스 인터페이스를 클라이언트에게 반환할 수 있다. 브릿지패턴 이라 알려진 것이다.<br/>
　　-- 의존 객체 주입(dependency injection) 프레임워크도 강력한 서비스 제공자라고 생각할 수 있다. <br/>
　　-- 자바 6의 ServiceLoader 라는 범용 서비스 제공자 프레임워크가 제공되어 프레임워크를 직접 만들 필요가 거의 없어졌다.


####정적 팩터리 메서드의 단점