## 4장 클래스와 인터페이스

------------------

#### 아이템 19 . 상속을 고려해 설계하고 문서화하라. 그러지않았다면 상속을 금지하라

아이템 18에서는 상속을 염두에 두지 않고 설계했고 상속할 때의 주의점도 문서화해놓지 않은 '외부'<br/>
클래스를 상속할 때의 위험을 경고했다. 여기서 '외부'란 프로그래머의 통제권 밖에 있어서 언제 어떻게<br/>
변경될지 모른다는 뜻이다. 상속을 고려한 설계와 문서화란 무엇일까?

우선, 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다. 달리 말하면,<br/>
상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야한다.<br/>
클래스의 API 로 공개된 메서드에서 클래스 자신의 또 다른 메서드를 호출할 수도 있다. 그런데 마침<br/>
호출되는 메서드가 재정의 가능 메서드라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다. 덧붙여서<br/>
어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야한다.('재정의 가능'<br/>
이란 public 과 protected 메서드 중 final 이 아닌 모든 메서드를 뜻한다.) 더 넓게 말하면, 재정의 가능<br/>
메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다. 예를 들어 백그라운드 스레드나 정적 초기화 과정<br/>
에서도 호출이 일어날 수 있다.

API 문서의 메서드 설명 끝에서 종종 'Implementation Requirements' 로 시작하는 절을 볼 수 있는데<br/>
그 메서드의 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독<br/>
도구가 생성해준다.다음은 java.util.AbstractCollection 에서 발췌한 예다.

```java
public boolean remove(Object o)
/**
 * 주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다(선택적 동작). 더 정확히 말하면, 이 컬렉션 안에 
 * 'Object.equals(o, e)가 참인 원소' e 가 하나 이상 있다면 그 중 하나를 제거한다. 주어진 원소가 컬렉션 안에 있었다면
 * (즉, 호출 결과 이 컬렉션이 변경 됐다면) true 를 반환한다.
 *  Implementation Requirements: 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었다. 주어진 원소를 찾으면
 *  반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진 객체를 갖고 있으나, 이 컬렉션의 iterator
 *  메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면 UnsupportedOperationException 을 던지니 주의하자.
 */
```
이 설명에 따르면 iterator 메서드를 재정의하면 remove 메서드의 동작에 영향을 줌을 확실히 알 수 있다. <br/>
iterator 메서드로 얻은 반복자의 동작이 remove 메서드의 동작에 주는 영향도 정확히 설명했다. 아이템18에서는<br/>
HashSet 을 상속하며 add 를 재정의한 것이 addAll 에 까지 영향을 준다는 사실을 알 수 없었는데 아주 대조적이다.